# GardenLog.V2024 - GitHub Copilot Instructions

## Project Overview
GardenLog.V2024 is a comprehensive garden management application built with modern .NET technologies. It provides tools for plant cataloging, harvest tracking, user management, growing conditions monitoring, and image management for gardening enthusiasts and professionals.

**Repository**: https://github.com/kravvya/GardenLog.V2024

## Architecture & Technologies
- **Platform**: .NET 9.0
- **Frontend**: Blazor WebAssembly
- **Architecture**: Clean Architecture with Domain-Driven Design (DDD)
- **Database**: MongoDB (via driver integration)
- **Authentication**: ASP.NET Core Identity with OAuth2/OpenID Connect
- **Infrastructure**: Azure services integration (Key Vault, Blob Storage)
- **Containerization**: Docker support for all API services
- **Testing**: xUnit with integration and unit tests
- **Build System**: Visual Studio Solution (.sln) with MSBuild

## Project Structure

### Solution Organization
```
GardenLog.V2024/
├── src/
│   ├── GardenLogWeb/                    # Blazor WebAssembly frontend
│   ├── GardenLog.SharedKernel/          # Shared domain primitives and utilities
│   ├── GardenLog.SharedInfrastructure/  # Shared infrastructure services
│   ├── PlantCatalog/                    # Plant management bounded context
│   │   ├── PlantCatalog.Api/            # REST API endpoints
│   │   ├── PlantCatalog.Domain/         # Domain models and business logic
│   │   ├── PlantCatalog.Infrastructure/ # Data access and external services
│   │   └── PlantCatalog.Contract/       # DTOs and service contracts
│   ├── UserManagement/                  # User management bounded context
│   ├── PlantHarvest/                    # Harvest tracking bounded context
│   ├── GrowConditions/                  # Environmental conditions bounded context
│   └── ImageCatalog/                    # Image management bounded context
├── tests/                               # Test projects (Integration & Unit)
├── proto/                               # Prototyping and experimental code
└── .github/                             # GitHub workflows and configuration
```

### Bounded Contexts
Each bounded context follows Clean Architecture principles:
- **Api**: Controllers, minimal APIs, middleware, authentication
- **Domain**: Entities, value objects, domain services, business rules
- **Infrastructure**: Repositories, data access, external service integrations
- **Contract**: DTOs, commands, queries, service interfaces

## Domain Knowledge

### Gardening Context
This application serves gardening enthusiasts and professionals. Key domain concepts:
- **Plants**: Varieties with growing instructions, harvest information, seasonal data
- **Plant Growing Instructions**: Planting methods, spacing, timing, environmental needs
- **Harvest Seasons**: Spring, Summer, Fall, Winter with specific timing
- **Weather Conditions**: Temperature, precipitation, growing zone considerations
- **Garden Planning**: Crop rotation, companion planting, succession planting
- **Plant Types**: Vegetables, herbs, flowers, perennials, annuals, biennials
- **Growing Methods**: Seed starting, transplanting, direct seeding
- **Plant Characteristics**: Sun requirements, water needs, spacing, mature size

### Business Rules
- Plants can have multiple growing instructions for different seasons/methods
- Harvest seasons determine planting timing and garden planning
- User gardens track specific environmental conditions and microclimates
- Images are associated with plants, harvests, and garden conditions
- Plant varieties may have different requirements based on growing zone

## Development Guidelines

### Coding Standards
- **Language**: C# 12+ with nullable reference types enabled
- **Framework**: .NET 9.0 with implicit usings
- **Async/Await**: Use async patterns for all I/O operations
- **Dependency Injection**: Constructor injection with proper service lifetimes
- **Logging**: Structured logging with ILogger<T>
- **Error Handling**: Use Result pattern or proper exception handling
- **Validation**: FluentValidation for input validation

### Architecture Patterns
- **Clean Architecture**: Dependency inversion with clear layer separation
- **Domain-Driven Design**: Rich domain models with business logic encapsulation
- **CQRS**: Command/Query separation where appropriate
- **Repository Pattern**: Data access abstraction with UnitOfWork
- **MediatR**: For command/query handling and cross-cutting concerns
- **Configuration**: Environment-based settings with Azure Key Vault integration

### Naming Conventions
- **Classes**: PascalCase (e.g., `PlantGrowInstruction`, `ConfigurationService`)
- **Methods**: PascalCase (e.g., `GetPlantGrowInstructions`, `UpdatePlantGrowInstruction`)
- **Properties**: PascalCase (e.g., `PlantId`, `HarvestSeason`)
- **Fields**: camelCase with underscore prefix for private (e.g., `_logger`, `_configuration`)
- **Interfaces**: IPascalCase (e.g., `IPlantRepository`, `IConfigurationService`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `VAULT_NAME`, `ENVIRONMENT`)

### Database & Data Access
- **MongoDB**: Document-based storage with BSON serialization
- **Repositories**: Async operations with proper error handling
- **Projections**: Use MongoDB projections for read-optimized queries
- **Collections**: Follow domain boundaries (Plants, Users, Harvests, etc.)
- **Indexing**: Consider query patterns for performance optimization
- **Data Modeling**: Embedded documents vs. references based on access patterns

### Authentication & Security
- **Authentication**: OAuth2/OpenID Connect with external providers
- **Authorization**: Role-based and policy-based authorization
- **Configuration**: Azure Key Vault for sensitive data
- **Secrets**: Environment variables and secure configuration
- **CORS**: Properly configured for frontend/backend communication
- **API Security**: Input validation, rate limiting, proper error responses

### Frontend (Blazor WebAssembly)
- **Components**: Reusable Razor components with proper lifecycle management
- **State Management**: Component state and service-based state sharing
- **HTTP Communication**: HttpClient with Polly for resilience
- **Authentication**: WebAssembly authentication with JWT tokens
- **Validation**: Client-side validation with FluentValidation
- **Styling**: Bootstrap 5 with custom CSS for garden-specific UI
- **Performance**: Lazy loading, virtualization for large lists

### Docker & Deployment
- **Containerization**: Each API service has its own Dockerfile
- **Base Images**: Microsoft .NET runtime and SDK images
- **Multi-stage Builds**: Optimize for production deployment
- **Environment Configuration**: Environment variables for container configuration
- **Health Checks**: Implement health check endpoints for container orchestration

### Testing Strategy
- **Unit Tests**: Domain logic, business rules, utilities
- **Integration Tests**: API endpoints, database operations, external services
- **Test Data**: Use test-specific data that doesn't interfere with development
- **Mocking**: Mock external dependencies and infrastructure concerns
- **Test Organization**: Mirror source structure in test projects
- **Coverage**: Focus on business-critical paths and edge cases

## Common Patterns

### Repository Pattern Implementation
```csharp
public interface IPlantRepository : IBaseRepository<Plant>
{
    Task<IReadOnlyCollection<PlantGrowInstructionViewModel>> GetPlantGrowInstructions(string plantId);
    Task<PlantGrowInstructionViewModel> GetPlantGrowInstruction(string plantId, string instructionId);
    void AddPlantGrowInstruction(string plantGrowInstructionId, Plant plant);
    void UpdatePlantGrowInstruction(string plantGrowInstructionId, Plant plant);
    void DeletePlantGrowInstruction(string plantGrowInstructionId, Plant plant);
}
```

### Configuration Service Pattern
```csharp
public interface IConfigurationService
{
    AuthSettings GetAuthSettings();
    string GetImageBlobConnectionString();
    string GetOpenWeatherApplicationId();
    MongoSettings? GetPlantCatalogMongoSettings();
}
```

### Domain Entity Pattern
```csharp
public class PlantGrowInstruction : BaseEntity
{
    public static PlantGrowInstruction Create(CreatePlantGrowInstructionCommand command) { /* Factory method */ }
    
    public void Update(UpdatePlantGrowInstructionCommand command, 
                      Action<PlantEventTriggerEnum, Events.Meta.TriggerEntity> addPlantEvent) { /* Business logic */ }
}
```

### Blazor Component Pattern
```razor
@inject ILogger<PlantGrowInstructionList> _logger
@inject IVerifyService _verifyService
@inject IPlantService _plantService

<article id="plantGrowInstructionList">
    <!-- Component markup -->
</article>

@code {
    [Parameter] public PlantModel? Plant { get; set; }
    private IList<PlantGrowInstructionViewModel>? _growInstructions { get; set; }
    
    protected override async Task OnInitializedAsync() { /* Initialization logic */ }
}
```

## Environment Configuration

### Development Setup
- **Prerequisites**: .NET 9.0 SDK, Visual Studio 2022, Docker Desktop
- **Local Development**: Use Development appsettings with local MongoDB
- **Authentication**: Configure OAuth2 providers for local testing
- **Secrets**: Use User Secrets for development credentials

### Build Commands
```bash
# Build entire solution
dotnet build GardenLogV2024.sln

# Run specific project
dotnet run --project src/GardenLogWeb/GardenLogWeb.csproj

# Run tests
dotnet test

# Docker build for API services
docker build -f src/PlantCatalog/PlantCatalog.Api/Dockerfile .
```

### Configuration Files
- **appsettings.json**: Base configuration
- **appsettings.Development.json**: Development overrides
- **appsettings.Production.json**: Production configuration
- **User Secrets**: Local development secrets

## Quality Gates

### Code Quality Checklist
- [ ] Follows Clean Architecture layer boundaries
- [ ] Implements proper error handling and logging
- [ ] Uses async/await patterns correctly
- [ ] Includes appropriate input validation
- [ ] Has meaningful unit and integration tests
- [ ] Follows established naming conventions
- [ ] Implements proper dependency injection
- [ ] Uses configuration services appropriately

### Domain Quality Checklist
- [ ] Business logic is encapsulated in domain entities
- [ ] Gardening domain concepts are properly modeled
- [ ] Plant and growing instruction relationships are correct
- [ ] Seasonal and environmental data is accurately represented
- [ ] User experience aligns with gardening workflows

### Security Checklist
- [ ] Sensitive data uses secure configuration
- [ ] Authentication and authorization are properly implemented
- [ ] Input validation prevents security vulnerabilities
- [ ] API endpoints have appropriate access controls
- [ ] Database queries prevent injection attacks

### Performance Checklist
- [ ] Database queries are optimized with proper indexing
- [ ] Frontend uses lazy loading and virtualization where appropriate
- [ ] API responses are properly cached when suitable
- [ ] Large data sets use pagination or streaming
- [ ] Docker images are optimized for size and startup time

## Common Use Cases

### Adding New Plant Features
When extending plant management functionality:
1. Start with domain model changes in PlantCatalog.Domain
2. Update repository interfaces and implementations
3. Create/update DTOs in PlantCatalog.Contract
4. Implement API endpoints in PlantCatalog.Api
5. Update frontend components in GardenLogWeb
6. Add appropriate tests for new functionality

### Integrating External Services
For new external integrations (weather, plant databases, etc.):
1. Define service contracts in SharedKernel or appropriate Contract project
2. Implement service in SharedInfrastructure or bounded context Infrastructure
3. Configure dependency injection and settings
4. Add appropriate error handling and resilience patterns
5. Include integration tests with proper mocking

### UI Component Development
For new Blazor components:
1. Follow established component patterns
2. Use dependency injection for services
3. Implement proper parameter validation
4. Include loading states and error handling
5. Apply consistent styling with Bootstrap and custom CSS
6. Consider accessibility and responsive design

## Troubleshooting

### Common Issues
- **MongoDB Connection**: Check connection strings and network accessibility
- **Authentication**: Verify OAuth2 configuration and redirect URIs
- **Docker Build**: Ensure Dockerfile context and dependency paths are correct
- **Blazor WASM**: Check CORS configuration and API base URLs
- **Configuration**: Verify Azure Key Vault access and environment variables

### Development Tools
- **Logging**: Use structured logging to trace request flows
- **Debugging**: Leverage Visual Studio debugging for both frontend and backend
- **Database**: Use MongoDB Compass or similar tools for data inspection
- **API Testing**: Use tools like Postman or Swagger UI for API validation
- **Container Debugging**: Use Docker logs and container inspection tools

## Best Practices Summary

1. **Follow Clean Architecture**: Maintain clear separation between layers
2. **Domain-First Design**: Start with domain modeling before technical implementation
3. **Async All The Way**: Use async patterns consistently throughout the stack
4. **Configuration Management**: Use secure, environment-aware configuration
5. **Error Handling**: Implement comprehensive error handling and logging
6. **Testing**: Write tests that cover business scenarios, not just technical functionality
7. **Security**: Apply security best practices at every layer
8. **Performance**: Consider performance implications of architectural decisions
9. **Documentation**: Keep documentation current with code changes
10. **Garden Domain**: Understand and respect the gardening domain when making technical decisions

---

This file should be referenced when working on any aspect of the GardenLog.V2024 project to ensure consistency with established patterns and practices.